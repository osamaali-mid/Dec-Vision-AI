{
  "version": 3,
  "sources": ["../../src/lib/webcam-manager.ts"],
  "sourcesContent": ["import { EventEmitter } from 'events';\n\nexport interface WebcamDevice {\n    id: string;\n    name: string;\n    isActive: boolean;\n    resolution?: string;\n    frameRate?: number;\n}\n\nexport interface WebcamStream {\n    deviceId: string;\n    isStreaming: boolean;\n    startTime: Date;\n    frameCount: number;\n    lastFrameTime?: Date;\n}\n\nexport class WebcamManager extends EventEmitter {\n    private activeStreams: Map<string, WebcamStream> = new Map();\n    private detectionInterval: NodeJS.Timeout | null = null;\n    private streamCheckInterval: NodeJS.Timeout | null = null;\n\n    constructor() {\n        super();\n        this.startStreamMonitoring();\n    }\n\n    /**\n     * Get available webcam devices\n     */\n    async getAvailableDevices(): Promise<WebcamDevice[]> {\n        // Simulate getting available devices\n        // In a real implementation, this would interface with system cameras\n        const devices: WebcamDevice[] = [\n            {\n                id: '0',\n                name: 'Default Camera',\n                isActive: false,\n                resolution: '1920x1080',\n                frameRate: 30\n            },\n            {\n                id: '1',\n                name: 'USB Camera',\n                isActive: false,\n                resolution: '1280x720',\n                frameRate: 25\n            },\n            {\n                id: 'reolink',\n                name: 'Reolink Network Camera',\n                isActive: false,\n                resolution: '2560x1440',\n                frameRate: 30\n            }\n        ];\n\n        // Mark active devices\n        devices.forEach(device => {\n            device.isActive = this.activeStreams.has(device.id);\n        });\n\n        return devices;\n    }\n\n    /**\n     * Start webcam stream\n     */\n    async startStream(deviceId: string): Promise<boolean> {\n        try {\n            if (this.activeStreams.has(deviceId)) {\n                throw new Error(`Stream already active for device ${deviceId}`);\n            }\n\n            // Simulate starting webcam stream\n            const stream: WebcamStream = {\n                deviceId,\n                isStreaming: true,\n                startTime: new Date(),\n                frameCount: 0\n            };\n\n            this.activeStreams.set(deviceId, stream);\n            \n            // Start frame simulation\n            this.simulateFrameCapture(deviceId);\n\n            this.emit('streamStarted', { deviceId, stream });\n            return true;\n\n        } catch (error) {\n            this.emit('error', { deviceId, error });\n            return false;\n        }\n    }\n\n    /**\n     * Stop webcam stream\n     */\n    async stopStream(deviceId: string): Promise<boolean> {\n        try {\n            const stream = this.activeStreams.get(deviceId);\n            if (!stream) {\n                return false;\n            }\n\n            stream.isStreaming = false;\n            this.activeStreams.delete(deviceId);\n\n            this.emit('streamStopped', { deviceId, stream });\n            return true;\n\n        } catch (error) {\n            this.emit('error', { deviceId, error });\n            return false;\n        }\n    }\n\n    /**\n     * Stop all active streams\n     */\n    async stopAllStreams(): Promise<void> {\n        const deviceIds = Array.from(this.activeStreams.keys());\n        \n        for (const deviceId of deviceIds) {\n            await this.stopStream(deviceId);\n        }\n    }\n\n    /**\n     * Get active streams\n     */\n    getActiveStreams(): WebcamStream[] {\n        return Array.from(this.activeStreams.values());\n    }\n\n    /**\n     * Check if device is streaming\n     */\n    isStreaming(deviceId: string): boolean {\n        const stream = this.activeStreams.get(deviceId);\n        return stream ? stream.isStreaming : false;\n    }\n\n    /**\n     * Get stream statistics\n     */\n    getStreamStats(deviceId: string): WebcamStream | null {\n        return this.activeStreams.get(deviceId) || null;\n    }\n\n    /**\n     * Capture frame from active stream\n     */\n    async captureFrame(deviceId: string): Promise<{\n        success: boolean;\n        frameData?: Buffer;\n        timestamp?: Date;\n        error?: string;\n    }> {\n        const stream = this.activeStreams.get(deviceId);\n        \n        if (!stream || !stream.isStreaming) {\n            return {\n                success: false,\n                error: `No active stream for device ${deviceId}`\n            };\n        }\n\n        try {\n            // Simulate frame capture\n            const frameData = Buffer.from('simulated-frame-data');\n            const timestamp = new Date();\n\n            // Update stream stats\n            stream.frameCount++;\n            stream.lastFrameTime = timestamp;\n\n            this.emit('frameCaptured', { deviceId, frameData, timestamp });\n\n            return {\n                success: true,\n                frameData,\n                timestamp\n            };\n\n        } catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error'\n            };\n        }\n    }\n\n    /**\n     * Set stream resolution\n     */\n    async setResolution(deviceId: string, width: number, height: number): Promise<boolean> {\n        const stream = this.activeStreams.get(deviceId);\n        \n        if (!stream) {\n            return false;\n        }\n\n        try {\n            // Simulate setting resolution\n            this.emit('resolutionChanged', { \n                deviceId, \n                resolution: `${width}x${height}` \n            });\n            \n            return true;\n        } catch (error) {\n            this.emit('error', { deviceId, error });\n            return false;\n        }\n    }\n\n    /**\n     * Set stream frame rate\n     */\n    async setFrameRate(deviceId: string, frameRate: number): Promise<boolean> {\n        const stream = this.activeStreams.get(deviceId);\n        \n        if (!stream) {\n            return false;\n        }\n\n        try {\n            // Simulate setting frame rate\n            this.emit('frameRateChanged', { deviceId, frameRate });\n            return true;\n        } catch (error) {\n            this.emit('error', { deviceId, error });\n            return false;\n        }\n    }\n\n    /**\n     * Cleanup resources\n     */\n    cleanup(): void {\n        if (this.detectionInterval) {\n            clearInterval(this.detectionInterval);\n            this.detectionInterval = null;\n        }\n\n        if (this.streamCheckInterval) {\n            clearInterval(this.streamCheckInterval);\n            this.streamCheckInterval = null;\n        }\n\n        this.stopAllStreams();\n    }\n\n    /**\n     * Simulate frame capture for active streams\n     */\n    private simulateFrameCapture(deviceId: string): void {\n        const interval = setInterval(() => {\n            const stream = this.activeStreams.get(deviceId);\n            \n            if (!stream || !stream.isStreaming) {\n                clearInterval(interval);\n                return;\n            }\n\n            // Simulate frame capture\n            this.captureFrame(deviceId);\n        }, 1000 / 30); // 30 FPS simulation\n    }\n\n    /**\n     * Monitor stream health\n     */\n    private startStreamMonitoring(): void {\n        this.streamCheckInterval = setInterval(() => {\n            const now = new Date();\n            \n            for (const [deviceId, stream] of this.activeStreams) {\n                if (stream.lastFrameTime) {\n                    const timeSinceLastFrame = now.getTime() - stream.lastFrameTime.getTime();\n                    \n                    // If no frame in last 5 seconds, consider stream unhealthy\n                    if (timeSinceLastFrame > 5000) {\n                        this.emit('streamUnhealthy', { \n                            deviceId, \n                            timeSinceLastFrame,\n                            stream \n                        });\n                    }\n                }\n            }\n        }, 10000); // Check every 10 seconds\n    }\n}"],
  "mappings": "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",
  "names": []
}
