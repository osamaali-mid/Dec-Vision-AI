{
  "version": 3,
  "sources": ["../../src/lib/detection-service.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport { EventEmitter } from 'events';\n\nexport interface DetectionResult {\n    type: 'motion' | 'person' | 'vehicle' | 'face' | 'dog_cat';\n    confidence: number;\n    timestamp: Date;\n    source: 'image' | 'video' | 'webcam';\n    boundingBox?: {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    };\n    metadata?: any;\n}\n\nexport interface DetectionConfig {\n    enableImageDetection: boolean;\n    enableVideoDetection: boolean;\n    enableWebcamDetection: boolean;\n    detectionThreshold: number;\n    supportedFormats: string[];\n    maxFileSize: number; // in MB\n}\n\nexport class DetectionService extends EventEmitter {\n    private config: DetectionConfig;\n    private isProcessing: boolean = false;\n    private supportedImageFormats = ['.jpg', '.jpeg', '.png', '.bmp', '.tiff'];\n    private supportedVideoFormats = ['.mp4', '.avi', '.mov', '.mkv', '.webm'];\n\n    constructor(config: DetectionConfig) {\n        super();\n        this.config = config;\n    }\n\n    /**\n     * Process image file for detection\n     */\n    async processImage(imagePath: string): Promise<DetectionResult[]> {\n        if (!this.config.enableImageDetection) {\n            throw new Error('Image detection is disabled');\n        }\n\n        if (!fs.existsSync(imagePath)) {\n            throw new Error(`Image file not found: ${imagePath}`);\n        }\n\n        const fileExtension = path.extname(imagePath).toLowerCase();\n        if (!this.supportedImageFormats.includes(fileExtension)) {\n            throw new Error(`Unsupported image format: ${fileExtension}`);\n        }\n\n        const fileStats = fs.statSync(imagePath);\n        const fileSizeMB = fileStats.size / (1024 * 1024);\n        \n        if (fileSizeMB > this.config.maxFileSize) {\n            throw new Error(`File size exceeds limit: ${fileSizeMB}MB > ${this.config.maxFileSize}MB`);\n        }\n\n        this.isProcessing = true;\n        this.emit('processingStarted', { type: 'image', path: imagePath });\n\n        try {\n            // Simulate AI detection processing\n            const results = await this.performDetection(imagePath, 'image');\n            \n            this.emit('detectionComplete', { \n                type: 'image', \n                path: imagePath, \n                results \n            });\n\n            return results;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Process video file for detection\n     */\n    async processVideo(videoPath: string): Promise<DetectionResult[]> {\n        if (!this.config.enableVideoDetection) {\n            throw new Error('Video detection is disabled');\n        }\n\n        if (!fs.existsSync(videoPath)) {\n            throw new Error(`Video file not found: ${videoPath}`);\n        }\n\n        const fileExtension = path.extname(videoPath).toLowerCase();\n        if (!this.supportedVideoFormats.includes(fileExtension)) {\n            throw new Error(`Unsupported video format: ${fileExtension}`);\n        }\n\n        const fileStats = fs.statSync(videoPath);\n        const fileSizeMB = fileStats.size / (1024 * 1024);\n        \n        if (fileSizeMB > this.config.maxFileSize) {\n            throw new Error(`File size exceeds limit: ${fileSizeMB}MB > ${this.config.maxFileSize}MB`);\n        }\n\n        this.isProcessing = true;\n        this.emit('processingStarted', { type: 'video', path: videoPath });\n\n        try {\n            // Process video frame by frame\n            const results = await this.performVideoDetection(videoPath);\n            \n            this.emit('detectionComplete', { \n                type: 'video', \n                path: videoPath, \n                results \n            });\n\n            return results;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Start webcam detection\n     */\n    async startWebcamDetection(deviceId?: string): Promise<void> {\n        if (!this.config.enableWebcamDetection) {\n            throw new Error('Webcam detection is disabled');\n        }\n\n        this.isProcessing = true;\n        this.emit('webcamDetectionStarted', { deviceId });\n\n        // Simulate continuous webcam detection\n        this.performContinuousWebcamDetection(deviceId);\n    }\n\n    /**\n     * Stop webcam detection\n     */\n    stopWebcamDetection(): void {\n        this.isProcessing = false;\n        this.emit('webcamDetectionStopped');\n    }\n\n    /**\n     * Get available webcam devices\n     */\n    async getAvailableWebcams(): Promise<Array<{ id: string; name: string }>> {\n        // Simulate getting available webcam devices\n        return [\n            { id: '0', name: 'Default Camera' },\n            { id: '1', name: 'USB Camera' },\n            { id: 'reolink', name: 'Reolink Camera' }\n        ];\n    }\n\n    /**\n     * Check if detection is currently running\n     */\n    isDetectionRunning(): boolean {\n        return this.isProcessing;\n    }\n\n    /**\n     * Update detection configuration\n     */\n    updateConfig(newConfig: Partial<DetectionConfig>): void {\n        this.config = { ...this.config, ...newConfig };\n        this.emit('configUpdated', this.config);\n    }\n\n    /**\n     * Simulate AI detection on image/video frame\n     */\n    private async performDetection(filePath: string, source: 'image' | 'video'): Promise<DetectionResult[]> {\n        // Simulate processing delay\n        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n\n        const results: DetectionResult[] = [];\n        const detectionTypes = ['motion', 'person', 'vehicle', 'face', 'dog_cat'] as const;\n\n        // Simulate random detections\n        for (const type of detectionTypes) {\n            if (Math.random() > 0.7) { // 30% chance of detection\n                const confidence = 0.5 + Math.random() * 0.5; // 50-100% confidence\n                \n                if (confidence >= this.config.detectionThreshold) {\n                    results.push({\n                        type,\n                        confidence,\n                        timestamp: new Date(),\n                        source,\n                        boundingBox: {\n                            x: Math.floor(Math.random() * 640),\n                            y: Math.floor(Math.random() * 480),\n                            width: 50 + Math.floor(Math.random() * 100),\n                            height: 50 + Math.floor(Math.random() * 100)\n                        },\n                        metadata: {\n                            filePath,\n                            processingTime: 1000 + Math.random() * 2000\n                        }\n                    });\n                }\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Process video file frame by frame\n     */\n    private async performVideoDetection(videoPath: string): Promise<DetectionResult[]> {\n        const allResults: DetectionResult[] = [];\n        const frameCount = 30; // Simulate 30 frames\n\n        for (let frame = 0; frame < frameCount; frame++) {\n            this.emit('videoProgress', { \n                frame: frame + 1, \n                total: frameCount, \n                percentage: ((frame + 1) / frameCount) * 100 \n            });\n\n            const frameResults = await this.performDetection(videoPath, 'video');\n            \n            // Add frame information to results\n            frameResults.forEach(result => {\n                result.metadata = {\n                    ...result.metadata,\n                    frameNumber: frame + 1,\n                    totalFrames: frameCount\n                };\n            });\n\n            allResults.push(...frameResults);\n\n            // Small delay between frames\n            await new Promise(resolve => setTimeout(resolve, 100));\n        }\n\n        return allResults;\n    }\n\n    /**\n     * Continuous webcam detection\n     */\n    private async performContinuousWebcamDetection(deviceId?: string): Promise<void> {\n        while (this.isProcessing) {\n            try {\n                const results = await this.performDetection(`webcam:${deviceId || '0'}`, 'video');\n                \n                if (results.length > 0) {\n                    this.emit('webcamDetection', {\n                        deviceId,\n                        results,\n                        timestamp: new Date()\n                    });\n                }\n\n                // Wait before next detection cycle\n                await new Promise(resolve => setTimeout(resolve, 1000));\n            } catch (error) {\n                this.emit('error', error);\n                break;\n            }\n        }\n    }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,WAAsB;AACtB,oBAA6B;AAyBtB,MAAM,yBAAyB,2BAAa;AAAA,EAM/C,YAAY,QAAyB;AACjC,UAAM;AALV,SAAQ,eAAwB;AAChC,SAAQ,wBAAwB,CAAC,QAAQ,SAAS,QAAQ,QAAQ,OAAO;AACzE,SAAQ,wBAAwB,CAAC,QAAQ,QAAQ,QAAQ,QAAQ,OAAO;AAIpE,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,WAA+C;AAC9D,QAAI,CAAC,KAAK,OAAO,sBAAsB;AACnC,YAAM,IAAI,MAAM,6BAA6B;AAAA,IACjD;AAEA,QAAI,CAAC,GAAG,WAAW,SAAS,GAAG;AAC3B,YAAM,IAAI,MAAM,yBAAyB,SAAS,EAAE;AAAA,IACxD;AAEA,UAAM,gBAAgB,KAAK,QAAQ,SAAS,EAAE,YAAY;AAC1D,QAAI,CAAC,KAAK,sBAAsB,SAAS,aAAa,GAAG;AACrD,YAAM,IAAI,MAAM,6BAA6B,aAAa,EAAE;AAAA,IAChE;AAEA,UAAM,YAAY,GAAG,SAAS,SAAS;AACvC,UAAM,aAAa,UAAU,QAAQ,OAAO;AAE5C,QAAI,aAAa,KAAK,OAAO,aAAa;AACtC,YAAM,IAAI,MAAM,4BAA4B,UAAU,QAAQ,KAAK,OAAO,WAAW,IAAI;AAAA,IAC7F;AAEA,SAAK,eAAe;AACpB,SAAK,KAAK,qBAAqB,EAAE,MAAM,SAAS,MAAM,UAAU,CAAC;AAEjE,QAAI;AAEA,YAAM,UAAU,MAAM,KAAK,iBAAiB,WAAW,OAAO;AAE9D,WAAK,KAAK,qBAAqB;AAAA,QAC3B,MAAM;AAAA,QACN,MAAM;AAAA,QACN;AAAA,MACJ,CAAC;AAED,aAAO;AAAA,IACX,UAAE;AACE,WAAK,eAAe;AAAA,IACxB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,WAA+C;AAC9D,QAAI,CAAC,KAAK,OAAO,sBAAsB;AACnC,YAAM,IAAI,MAAM,6BAA6B;AAAA,IACjD;AAEA,QAAI,CAAC,GAAG,WAAW,SAAS,GAAG;AAC3B,YAAM,IAAI,MAAM,yBAAyB,SAAS,EAAE;AAAA,IACxD;AAEA,UAAM,gBAAgB,KAAK,QAAQ,SAAS,EAAE,YAAY;AAC1D,QAAI,CAAC,KAAK,sBAAsB,SAAS,aAAa,GAAG;AACrD,YAAM,IAAI,MAAM,6BAA6B,aAAa,EAAE;AAAA,IAChE;AAEA,UAAM,YAAY,GAAG,SAAS,SAAS;AACvC,UAAM,aAAa,UAAU,QAAQ,OAAO;AAE5C,QAAI,aAAa,KAAK,OAAO,aAAa;AACtC,YAAM,IAAI,MAAM,4BAA4B,UAAU,QAAQ,KAAK,OAAO,WAAW,IAAI;AAAA,IAC7F;AAEA,SAAK,eAAe;AACpB,SAAK,KAAK,qBAAqB,EAAE,MAAM,SAAS,MAAM,UAAU,CAAC;AAEjE,QAAI;AAEA,YAAM,UAAU,MAAM,KAAK,sBAAsB,SAAS;AAE1D,WAAK,KAAK,qBAAqB;AAAA,QAC3B,MAAM;AAAA,QACN,MAAM;AAAA,QACN;AAAA,MACJ,CAAC;AAED,aAAO;AAAA,IACX,UAAE;AACE,WAAK,eAAe;AAAA,IACxB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAqB,UAAkC;AACzD,QAAI,CAAC,KAAK,OAAO,uBAAuB;AACpC,YAAM,IAAI,MAAM,8BAA8B;AAAA,IAClD;AAEA,SAAK,eAAe;AACpB,SAAK,KAAK,0BAA0B,EAAE,SAAS,CAAC;AAGhD,SAAK,iCAAiC,QAAQ;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,sBAA4B;AACxB,SAAK,eAAe;AACpB,SAAK,KAAK,wBAAwB;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,sBAAoE;AAEtE,WAAO;AAAA,MACH,EAAE,IAAI,KAAK,MAAM,iBAAiB;AAAA,MAClC,EAAE,IAAI,KAAK,MAAM,aAAa;AAAA,MAC9B,EAAE,IAAI,WAAW,MAAM,iBAAiB;AAAA,IAC5C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,qBAA8B;AAC1B,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,WAA2C;AACpD,SAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAG,UAAU;AAC7C,SAAK,KAAK,iBAAiB,KAAK,MAAM;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,UAAkB,QAAuD;AAEpG,UAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,MAAO,KAAK,OAAO,IAAI,GAAI,CAAC;AAE7E,UAAM,UAA6B,CAAC;AACpC,UAAM,iBAAiB,CAAC,UAAU,UAAU,WAAW,QAAQ,SAAS;AAGxE,eAAW,QAAQ,gBAAgB;AAC/B,UAAI,KAAK,OAAO,IAAI,KAAK;AACrB,cAAM,aAAa,MAAM,KAAK,OAAO,IAAI;AAEzC,YAAI,cAAc,KAAK,OAAO,oBAAoB;AAC9C,kBAAQ,KAAK;AAAA,YACT;AAAA,YACA;AAAA,YACA,WAAW,oBAAI,KAAK;AAAA,YACpB;AAAA,YACA,aAAa;AAAA,cACT,GAAG,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,cACjC,GAAG,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,cACjC,OAAO,KAAK,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,cAC1C,QAAQ,KAAK,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,YAC/C;AAAA,YACA,UAAU;AAAA,cACN;AAAA,cACA,gBAAgB,MAAO,KAAK,OAAO,IAAI;AAAA,YAC3C;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,sBAAsB,WAA+C;AAC/E,UAAM,aAAgC,CAAC;AACvC,UAAM,aAAa;AAEnB,aAAS,QAAQ,GAAG,QAAQ,YAAY,SAAS;AAC7C,WAAK,KAAK,iBAAiB;AAAA,QACvB,OAAO,QAAQ;AAAA,QACf,OAAO;AAAA,QACP,aAAc,QAAQ,KAAK,aAAc;AAAA,MAC7C,CAAC;AAED,YAAM,eAAe,MAAM,KAAK,iBAAiB,WAAW,OAAO;AAGnE,mBAAa,QAAQ,YAAU;AAC3B,eAAO,WAAW;AAAA,UACd,GAAG,OAAO;AAAA,UACV,aAAa,QAAQ;AAAA,UACrB,aAAa;AAAA,QACjB;AAAA,MACJ,CAAC;AAED,iBAAW,KAAK,GAAG,YAAY;AAG/B,YAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,GAAG,CAAC;AAAA,IACzD;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iCAAiC,UAAkC;AAC7E,WAAO,KAAK,cAAc;AACtB,UAAI;AACA,cAAM,UAAU,MAAM,KAAK,iBAAiB,UAAU,YAAY,GAAG,IAAI,OAAO;AAEhF,YAAI,QAAQ,SAAS,GAAG;AACpB,eAAK,KAAK,mBAAmB;AAAA,YACzB;AAAA,YACA;AAAA,YACA,WAAW,oBAAI,KAAK;AAAA,UACxB,CAAC;AAAA,QACL;AAGA,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,GAAI,CAAC;AAAA,MAC1D,SAAS,OAAO;AACZ,aAAK,KAAK,SAAS,KAAK;AACxB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
